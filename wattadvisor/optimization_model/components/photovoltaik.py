from datetime import datetime

import pyomo.environ as pyoe
import pandas as pd

from ..utils.feedin_tools import pv_normed_feedin_from_era5
from .base import Component
import wattadvisor.data_models.enums as enums


class Photovoltaik(Component):
    def __init__(self, 
                 name: str, 
                 interest_rate: float, 
                 parameters: dict,
                 latitude: float, 
                 longitude: float, 
                 weather_data: pd.DataFrame, 
                 installed_power: float, 
                 potential_power: float | None = None, 
                 capex: float | None = None, 
                 opex: float | None = None, 
                 lifespan: float | None = None, 
                 azimuth: float = 180, 
                 tilt: float = 40, 
                 elevation: float = 0):
        
        """Component to generate electrical energy from solar energy.

        Parameters
        ----------
        name : str
            Name of the component
        interest_rate : float
            Interest rate to determine annuity factor for investment calculation of the component, by default None 
        parameters : dict
            Dictionary of techno-economic parameters of the component, by default None.
            A dict of the following structure is expeceted. 
            At least one key at first level ("scalars" or "tabs") is required:

            .. code-block:: json

                {
                    "scalars": {
                        "parameter_title": 0
                    },
                    "tabs": {
                        "tab_title": {
                            "key_1": 1,
                            "key_2": 2
                        }
                    }
                }


        latitude : float
            Latitude of the location of the component
        longitude : float
            Longitude of the location of the component
        weather_data : pd.DataFrame
            Time series of hourly weather data for one year generated by the function call :func:`wattadvisor.optimization_model.utils.weather_data.get_weather_data_from_file`
        installed_power : float
            Already installed electrical power of the component [kW] which acts as a lower bound
        potential_power : float | None, optional
            Maximum installable electrical power of the component [kW], by default None
        capex : float | None, optional
            Capital expenditure cost of the component per electrical power [€/kW], by default None
        opex : float | None, optional
            Operational expenditure cost of the component per CAPEX per year [%/a], by default None
        lifespan : float | None, optional
            Expected lifespan of the component [a], by default None
        azimuth : float, optional
            Azimuth orientation [°] of the photovoltaic plant where the power will be generated, by default 180

            - North=0
            - East=90
            - South=180
            - West=270

        tilt : float, optional
            Tilt orientation [°] of the photovoltaic plant where the power will be generated, by default 40
            
            - Up=0
            - horizon=90

        elevation : float, optional
            elevation of the location of the photovoltaic plant above sea level [m], by default 0
        """
        
        super().__init__(name, interest_rate, parameters)

        self.installed_power = installed_power
        self.potential_power = potential_power
        self.weather_data = weather_data
        self.latitude = latitude
        self.longitude = longitude
        self.azimuth = azimuth
        self.tilt = tilt
        self.elevation = elevation 
        
        if capex is not None:
            self.capex = capex
        
        if opex is not None:
            self.opex = opex
        
        if lifespan is not None:
            self.lifespan = lifespan

    def _load_params(self, model: pyoe.Model, t: pyoe.RangeSet) -> pyoe.Model:
        
        normed_production = pv_normed_feedin_from_era5(
            latitude=self.latitude,
            longitude=self.longitude,
            azimuth=self.azimuth,
            tilt=self.tilt,
            surface_type="urban",
            start_date=datetime(2022, 1, 1),
            end_date=datetime(2023, 1, 1),
            elevation=self.elevation,
            pvlib_df=self.weather_data
        )
        
        normed_production = normed_production.clip(0).set_axis(t).to_dict()

        self.normed_production = pyoe.Param(t, initialize=normed_production)
        model.add_component(f'{self.name}_normed_production', self.normed_production)

        return model
        
    def _add_variables(self, model: pyoe.Model, t: pyoe.RangeSet) -> pyoe.Model:

        #(Output) electrical power [kW]
        self.produced_electrical=pyoe.Var(t, bounds=(0.0, None))
        model.add_component('{}_produced_electrical'.format(self.name), self.produced_electrical)

        # total cost, which is evaluated in the target function
        self.z=pyoe.Var(bounds=(0.0, None))
        model.add_component('{}_z'.format(self.name), self.z)

        # annual running cost
        self.running_cost=pyoe.Var(bounds=(0.0, None))
        model.add_component('{}_running_cost'.format(self.name), self.running_cost)

        # one-time installation cost
        self.installation_cost = pyoe.Var(bounds=(0.0, None))
        model.add_component('{}_installation_cost'.format(self.name), self.installation_cost)

        # peak power [kWp], that needs to be installed
        self.max_power=pyoe.Var(bounds=(self.installed_power, self.potential_power))
        model.add_component('{}_max_power'.format(self.name), self.max_power)

        self.bilance_variables.output[enums.EnergyType.ELECTRICAL] = self.produced_electrical

        return model

    def _add_constraints(self, model: pyoe.Model, t: pyoe.RangeSet) -> pyoe.Model:

        # calculating total cost, costs depending on peak power and eventually co2 emissions
        self.eq01=pyoe.Constraint(expr=self.z ==self.installation_cost * self.annuity_factor + self.running_cost)
        model.add_component('{}_eq01'.format(self.name), self.eq01)

        # calculating electrical output by applying the peak power to the standard profile
        self.eq02=pyoe.ConstraintList()
        model.add_component('{}_eq02'.format(self.name), self.eq02)
        for tx in t:
            self.eq02.add(self.produced_electrical[tx] == self.max_power * self.normed_production[tx])

        #calculate the annual running cost
        self.eq04=pyoe.Constraint(expr=self.running_cost == self.installation_cost * self.opex/100)
        model.add_component('{}_eq04'.format(self.name), self.eq04)

        #calculate the one-time installation cost
        self.eq05=pyoe.Constraint(expr=self.installation_cost == self.max_power * self.capex)
        model.add_component('{}_eq05'.format(self.name), self.eq05)

        return model
    
class PhotovoltaikRoof(Photovoltaik):
    pass

class PhotovoltaikFreeField(Photovoltaik):
    pass